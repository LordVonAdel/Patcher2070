/**
 * Sources:
 * https://github.com/kskudlik/Anno-1800-Model-Converter/blob/master/RDM-Converter/src/RDMFile.cpp
 */
import VertexFormat from "./VertexFormat.js";
import { Buffer } from "buffer";
import FileAsset from "../Common/FileAsset.js";

/**
 * RDM is the file extension for 3D models. It holds mostly geometry data. Metadata about models is saved in .cfg files.
 */
export default class RDMAsset extends FileAsset {

  constructor() {
    super();

    /**
     * @property {Buffer} raw
     */
    this.raw = null;

    this.vertices = [];
    this.triangles = [];
    this.materials = [];

    this.vertexFormat = null;
  }

  /**
   * @param {Buffer} data 
   */
  readData(data) {
    if (this.raw) throw new Error("Model already loaded!");

    this.raw = data;

    // Offsets
    const offsetsStart = data.readUInt32LE(32);
    if (offsetsStart < 32) throw new Error("Offsets offset to low.");

    const offsetsVertices = data.readUInt32LE(offsetsStart + 12);
    const offsetsTriangles = data.readUInt32LE(offsetsStart + 16);
    const offsetsMaterials = data.readUInt32LE(offsetsStart + 20);

    // Materials
    const materialSize = data.readUInt32LE(offsetsMaterials - 4);
    const materialNumber = data.readUInt32LE(offsetsMaterials - 8);
    for (let i = 0; i < materialNumber; i++) {
      const offset = offsetsMaterials + i * 28;
      const material = new RDMMaterial(data, offset);
      this.materials.push(material);
    }

    // Vertices
    const vertexNumber = data.readUInt32LE(offsetsVertices - 8);
    const vertexSize = data.readUInt32LE(offsetsVertices - 4);
    
    this.vertexFormat = VertexFormat.getBySize(vertexSize);
    for (let i = 0; i < vertexNumber; i++) {
      const offset = offsetsVertices + i * vertexSize;
      const vertex = this.vertexFormat.read(data.slice(offset, offset + vertexSize));
      this.vertices.push(vertex);
    }

    // Triangles
    const triangleNumber = data.readUInt32LE(offsetsTriangles - 8) / 3;
    const triangleSize = data.readUInt32LE(offsetsTriangles - 4); // Size per index in bytes

    for (let i = 0; i < triangleNumber; i++) {
      const offset = offsetsTriangles + i * 3 * triangleSize;

      if (triangleSize == 4) {
        this.triangles.push([
          data.readUInt32LE(offset),
          data.readUInt32LE(offset + 2),
          data.readUInt32LE(offset + 4)
        ]);
      } else if (triangleSize == 2) {
        this.triangles.push([
          data.readUInt16LE(offset),
          data.readUInt16LE(offset + 2),
          data.readUInt16LE(offset + 4)
        ]);
      } else {
        throw new Error("Unsupported triangle size: " + triangleSize);
      }
    }

    this.validateTriangles();
  }

  validateTriangles() {
    if (this.raw == null) throw new Error("Model not loaded!");

    for (let triangle of this.triangles) {
      for (let index of triangle) {
        if (index >= this.vertices.length) {
          throw new Error("Invalid vertex index");
        }
      }
    }
    return true;
  }

  /**
   * @returns {string} OBJ string
   */
  exportOBJ(mtllib = null) {
    if (this.raw == null) throw new Error("Model not loaded!");

    let out = "# Generated by RDMReader\n";
    if (mtllib) {
      out += `mtllib ${mtllib}\n`;
    }
    out += "usemtl mat_0\n";

    /// === Vertices ===
    // Positions
    for (let vertex of this.vertices) {
      out += `v ${vertex.position[0]} ${vertex.position[1]} ${vertex.position[2]}\n`;
    }

    // Normals
    if (this.vertexFormat.hasAttribute("normal")) {
      for (let vertex of this.vertices) {
        out += `vn ${vertex.normal[0]} ${vertex.normal[1]} ${vertex.normal[2]}\n`;
      }
    }

    // Texture coordinates
    if (this.vertexFormat.hasAttribute("texcoord")) {
      for (let vertex of this.vertices) {
        out += `vt ${vertex.texcoord[0]} ${vertex.texcoord[1]}\n`;
      }
    }

    /// === Faces ===
    // Triangles
    for (let triangle of this.triangles) {
      // Obj index starts at 1
      const i1 = triangle[0] + 1;
      const i2 = triangle[1] + 1;
      const i3 = triangle[2] + 1;
      out += `f ${i1}/${i1}/${i1} ${i2}/${i2}/${i2} ${i3}/${i3}/${i3}\n`;
    }

    return out;
  }

  exportMTL() {
    let out = "";
    for (let material of this.materials) {
      out += material.toMTL() + "\n";
    }
    return out;
  }
}

class RDMMaterial {
  constructor(data, offset) {
    this.offset = data.readUInt32LE(offset);
    this.size = data.readUInt32LE(offset + 4);
    this.index = data.readUInt32LE(offset + 8);

    this.ambientColor = [0.5, 0.5, 0.5, 1];
    this.diffuseColor = [1, 1, 1, 1];
    this.specularColor = [0, 0, 0, 1];
    this.emissiveColor = [0, 0, 0, 1];

    this.diffuseMap = null;
    this.specularMap = null;
    this.enviromentMap = null;
    this.shaderIndex = 0;
  }

  toMTL() {
    let out = "";

    out += `newmtl mat_${this.index}\n`;
    out += `Ka ${this.ambientColor[0]} ${this.ambientColor[1]} ${this.ambientColor[2]}\n`;
    out += `Kd ${this.diffuseColor[0]} ${this.diffuseColor[1]} ${this.diffuseColor[2]}\n`;
    out += `Ks ${this.specularColor[0]} ${this.specularColor[1]} ${this.specularColor[2]}\n`;
    out += `Ke ${this.emissiveColor[0]} ${this.emissiveColor[1]} ${this.emissiveColor[2]}\n`;

    if (this.diffuseMap) {
      out += `map_Kd ${this.diffuseMap}\n`;
    }

    if (this.specularMap) {
      out += `map_Ks ${this.specularMap}\n`;
    }

    if (this.enviromentMap) {
      out += `map_bump ${this.enviromentMap}\n`;
    }

    return out;
  }
}